# [PackageDev] target_format: plist, ext: tmLanguage
---
name: TypeScript
scopeName: source.ts
fileTypes: [ts]
uuid: ef98eb90-bf9b-11e4-bb52-0800200c9a66

patterns:
- include: '#statements'

repository:
  statements:
    patterns:
    - include: '#string'
    - include: '#regex'
    - include: '#template'
    - include: '#comment'
    - include: '#literal'
    - include: '#declaration'
    - include: '#switch-statement'
    - include: '#for-loop'
    - include: '#after-operator-block'
    - include: '#decl-block'
    - include: '#control-statement'
    # add label
    - include: '#expression'
    - include: '#punctuation-semicolon'

  var-expr:
    name: meta.var.expr.ts
    begin: (?<!\.|\$)(?:(\bexport)\s+)?\b(var|let|const(?!\s+enum\b))\b(?!\$)
    beginCaptures:
      '1': { name: keyword.control.export.ts }
      '2': { name: storage.type.ts }
    end: (?=$|;|}|(\s+(of|in)\s+))
    patterns:
    - include: '#destructuring-variable'
    - include: '#var-single-variable'
    - include: '#comment'
    - include: '#punctuation-comma'

  var-single-variable:
    name: meta.var-single-variable.expr.ts
    begin: ([_$[:alpha:]][_$[:alnum:]]*)
    beginCaptures:
      '1': { name: variable.other.readwrite.ts }
    end: (?=$|[;,}]|(\s+(of|in)\s+))
    patterns:
    - include: '#variable-initializer'
    - begin: \G
      end: (?!\G)(?=$|[;,=}]|(\s+(of|in)\s+))
      patterns:
      - include: '#type-annotation'
      - include: '#string'
      - include: '#comment'

  destructuring-variable:
    patterns:
    - name: meta.object-binding-pattern-variable.ts
      begin: (?<!=|:|of|in)\s*(\{)
      beginCaptures:
        '1': { name: punctuation.definition.binding-pattern.object.ts }
      end: (?=$|[;,}]|(\s+(of|in)\s+))
      patterns:
      - include: '#variable-initializer'
      - begin: (?<=\{)
        end: (?=$|[;,=}]|(\s+(of|in)\s+))
        patterns:
        - begin: (?<=\{)
          end: \}
          endCaptures:
            '0': { name: punctuation.definition.binding-pattern.object.ts }
          patterns:
          - include: '#object-binding-element'
        - include: '#type-annotation'
        - include: '#comment'
    - name: meta.array-binding-pattern-variable.ts
      begin: (?<!=|:|of|in)\s*(\[)
      beginCaptures:
        '1': { name: punctuation.definition.binding-pattern.array.ts }
      end: (?=$|[;,}]|(\s+(of|in)\s+))
      patterns:
      - include: '#variable-initializer'
      - begin: (?<=\[)
        end: (?=$|[;,=}]|(\s+(of|in)\s+))
        patterns:
        - begin: (?<=\[)
          end: \]
          endCaptures:
            '0': { name: punctuation.definition.binding-pattern.array.ts }
          patterns:
          - include: '#array-binding-element'
        - include: '#type-annotation'
        - include: '#comment'

  object-binding-element:
    patterns:
    - include: '#comment'
    - begin: ([_$[:alpha:]][_$[:alnum:]]*)\s*(:)
      beginCaptures:
        '1': { name: variable.object.property.ts }
        '2': { name: punctuation.destructuring.ts }
      end: (?=,|\})
      patterns:
      - include: '#object-binding-pattern'
      - include: '#array-binding-pattern'
      - name: variable.other.readwrite.ts
        match: ([_$[:alpha:]][_$[:alnum:]]*)
    - name: variable.other.readwrite.ts
      match: ([_$[:alpha:]][_$[:alnum:]]*)
    - name: meta.delimiter.object.comma.ts
      match: ','

  array-binding-element:
    patterns:
    - include: '#comment'
    - include: '#object-binding-pattern'
    - include: '#array-binding-pattern'
    - name: variable.other.readwrite.ts
      match: ([_$[:alpha:]][_$[:alnum:]]*)
    - name: meta.delimiter.object.comma.ts
      match: ','

  object-binding-pattern:
    begin: \{
    beginCaptures:
      '0': { name: punctuation.definition.binding-pattern.object.ts }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.binding-pattern.object.ts }
    patterns:
    - include: '#object-binding-element'

  array-binding-pattern:
    begin: \[
    beginCaptures:
      '0': { name: punctuation.definition.binding-pattern.array.ts }
    end: \]
    endCaptures:
      '0': { name: punctuation.definition.binding-pattern.array.ts }
    patterns:
    - include: '#array-binding-element'

  ternary-expression:
    begin: (?=\?)
    end: (?=$|[;,})\]])
    patterns:
    - include: '#ternary-operator'
    - include: '#expression' 

  ternary-operator:
    begin: (\?)
    beginCaptures:
      '0': { name: keyword.operator.ternary.ts }
    end: (:)
    endCaptures:
      '0': { name: keyword.operator.ternary.ts }      
    patterns:
    - include: '#expression' 

  expression:
    name: meta.expression.ts
    patterns:
    - include: '#string'
    - include: '#regex'
    - include: '#template'
    - include: '#comment'
    - include: '#literal'
    - include: '#function-declaration'
    - include: '#class-or-interface-declaration'
    - include: '#arrow-function'
    - include: '#cast'
    - include: '#ternary-expression'
    - include: '#new-expr'
    - include: '#object-literal'
    - include: '#expression-operator'
    - include: '#operators'
    - include: '#support-objects'
    - include: '#function-call'
    - include: '#identifiers'
    - include: '#paren-expression'
    - include: '#punctuation-comma'
    - include: '#punctuation-accessor'

  control-statement:
    # TODO: convert this to actual statements instead
    patterns:
    - name: keyword.control.trycatch.ts
      match: (?<!\.|\$)\b(catch|finally|throw|try)\b(?!\$)
    - name: keyword.control.loop.ts
      match: (?<!\.|\$)\b(break|continue|do|goto|while)\b(?!\$)
    - name: keyword.control.flow.ts
      match: (?<!\.|\$)\b(return)\b(?!\$)
    - match: (?<!\.|\$)\b(yield)\b(?!\$)(?:\s*(\*))?
      captures:
        '1': { name: keyword.control.flow.ts }
        '2': { name: keyword.generator.asterisk.ts }
    - name: keyword.control.switch.ts
      match: (?<!\.|\$)\b(case|default|switch)\b(?!\$)
    - name: keyword.control.conditional.ts
      match: (?<!\.|\$)\b(else|if)\b(?!\$)
    - name: keyword.control.with.ts
      match: (?<!\.|\$)\b(with)\b(?!\$)
    - name: keyword.other.debugger.ts
      match: (?<!\.|\$)\b(debugger)\b(?!\$)
    - name: storage.modifier.ts
      match: (?<!\.|\$)\b(declare)\b(?!\$)

  declaration:
    name: meta.declaration.ts
    patterns:
     - include: '#decorator'
     - include: '#var-expr'
     - include: '#function-declaration'
     - include: '#class-or-interface-declaration'
     - include: '#type-declaration'
     - include: '#enum-declaration'
     - include: '#namespace-declaration'
     - include: '#import-equals-declaration'
     - include: '#import-declaration'
     - include: '#export-declaration'

  decorator:
    name: meta.decorator.ts
    begin: (?<!\.|\$)\@
    beginCaptures:
      '0': { name: punctuation.decorator.ts }
    end: (?=\s)
    patterns:
    - include: '#expression'

  type-declaration:
    name: meta.type.declaration.ts
    begin: (?<!\.|\$)(?:(\bexport)\s+)?\b(type)\b\s+([_$[:alpha:]][_$[:alnum:]]*)\s*
    beginCaptures:
      '1': { name: keyword.control.export.ts }
      '2': { name: storage.type.type.ts }
      '3': { name: entity.name.type.ts }
    end: (?=[};]|\bvar\b|\blet\b|\bconst\b|\btype\b|\bfunction\b|\bclass\b|\binterface\b|\bnamespace\b|\bmodule\b|\bimport\b|\benum\b|\bdeclare\b|\bexport\b|\babstract\b|\basync\b)
    patterns:
      - include: '#comment'
      - include: '#type-parameters'
      - include: '#type'
      - match: '(=)\s*'
        captures:
          '1': { name: keyword.operator.assignment.ts }

  enum-declaration:
    name: meta.enum.declaration.ts
    match: (?<!\.|\$)(?:(\bexport)\s+)?(?:\b(const)\s+)?\b(enum)\s+([_$[:alpha:]][_$[:alnum:]]*)
    captures:
      '1': { name: keyword.control.export.ts }
      '2': { name: storage.modifier.ts}
      '3': { name: storage.type.enum.ts }
      '4': { name: entity.name.type.enum.ts }

  namespace-declaration:
    name: meta.namespace.declaration.ts
    begin: (?<!\.|\$)(?:(\bexport)\s+)?\b(namespace|module)\s+
    beginCaptures:
      '1': { name: keyword.control.export.ts }
      '2': { name: storage.type.namespace.ts }
    end: (?=$|\{)
    patterns:
    - include: '#comment'
    - include: '#string'
    - name: entity.name.type.module.ts
      match: ([_$[:alpha:]][_$[:alnum:]]*)
    - name: punctuation.accessor.ts
      match: \.      

  import-equals-declaration: 
    patterns:
    - name: meta.import-equals.external.ts
      begin: (?<!\.|\$)(?:(\bexport)\s+)?\b(import)\s+([_$[:alpha:]][_$[:alnum:]]*)\s*(=)\s*(require)\s*(\()
      beginCaptures:
        '1': { name: keyword.control.export.ts }
        '2': { name: keyword.control.import.ts }
        '3': { name: variable.other.readwrite.alias.ts }
        '4': { name: keyword.operator.assignment.ts }
        '5': { name: keyword.control.require.ts }
        '6': { name: meta.brace.round.ts }
      end: \)
      endCaptures:
        '0': { name: meta.brace.round.ts }
      patterns:
        - include: '#comment'
        - include: '#string'
    - name: meta.import-equals.internal.ts
      begin: (?<!\.|\$)(?:(\bexport)\s+)?\b(import)\s+([_$[:alpha:]][_$[:alnum:]]*)\s*(=)\s*(?!require\b)
      beginCaptures:
        '1': { name: keyword.control.export.ts }
        '2': { name: keyword.control.import.ts }
        '3': { name: variable.other.readwrite.alias.ts }
        '4': { name: keyword.operator.assignment.ts }
      end: (?=;|$)
      patterns:
        - include: '#comment'
        - match: ([_$[:alpha:]][_$[:alnum:]]*)\s*(\.)
          captures:
            '1': { name: entity.name.type.module.ts }
            '2': { name: punctuation.accessor.ts }
        - name: variable.other.readwrite.ts
          match: ([_$[:alpha:]][_$[:alnum:]]*)

  import-declaration:
    name: meta.import.ts
    begin: (?<!\.|\$)(?:(\bexport)\s+)?\b(import)(?!(\s*:)|(\$))\b
    beginCaptures:
      '1': { name: keyword.control.export.ts }
      '2': { name: keyword.control.import.ts }
    end: (?=;|$)
    patterns:
    - include: '#import-export-declaration'

  export-declaration:
    patterns:
    - match: (?<!\.|\$)\b(export)\s+(as)\s+(namespace)\s+([_$[:alpha:]][_$[:alnum:]]*)
      captures:
        '1': { name: keyword.control.export.ts }
        '2': { name: keyword.control.as.ts }
        '3': { name: storage.type.namespace.ts }
        '4': { name: entity.name.type.module.ts }
    - name: meta.export.default.ts
      begin: (?<!\.|\$)\b(export)(?:(?:\s*(=))|(?:\s+(default)(?=\s+)))
      beginCaptures:
        '1': { name: keyword.control.export.ts }
        '2': { name: keyword.operator.assignment.ts }
        '3': { name: keyword.control.default.ts }
      end: (?=;|\bexport\b|\bfunction\b|\bclass\b|\binterface\b|\blet\b|\bvar\b|\bconst\b|\bimport\b|\benum\b|\bnamespace\b|\bmodule\b|\btype\b|\babstract\b|\bdeclare\b|\basync\b|$)
      patterns:
      - include: '#expression'
    - name: meta.export.ts
      begin: (?<!\.|\$)\b(export)(?!(\s*:)|(\$))\b
      beginCaptures:
        '0': { name: keyword.control.export.ts }
      end: (?=;|\bexport\b|\bfunction\b|\bclass\b|\binterface\b|\blet\b|\bvar\b|\bconst\b|\bimport\b|\benum\b|\bnamespace\b|\bmodule\b|\btype\b|\babstract\b|\bdeclare\b|\basync\b|$)
      patterns:
      - include: '#import-export-declaration'
  
  import-export-declaration:
    patterns:
    - include: '#comment'
    - include: '#string'
    - include: '#import-export-block'
    - name: keyword.control.from.ts
      match: \bfrom\b
    - include: '#import-export-clause'

  import-export-block:
    name: meta.block.ts
    begin: \{
    beginCaptures:
      '0': { name: punctuation.definition.block.ts }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.block.ts }
    patterns:
    - include: '#import-export-clause'

  import-export-clause:
    patterns:
    - include: '#comment'
    - comment: (default|*|name) as alias
      match: '(?x) (?: \b(default)\b | (\*) | ([_$[:alpha:]][_$[:alnum:]]*)) \s+ 
        (as) \s+ (?: (\b default \b | \*) | ([_$[:alpha:]][_$[:alnum:]]*))'
      captures:
        '1': { name: keyword.control.default.ts }
        '2': { name: constant.language.import-export-all.ts }
        '3': { name: variable.other.readwrite.ts }
        '4': { name: keyword.control.as.ts }
        '5': { name: invalid.illegal.ts }
        '6': { name: variable.other.readwrite.alias.ts }
    - name: meta.delimiter.object.comma.ts
      match: ','
    - name: constant.language.import-export-all.ts
      match: \*
    - name: keyword.control.default.ts
      match: \b(default)\b
    - name: variable.other.readwrite.alias.ts
      match: ([_$[:alpha:]][_$[:alnum:]]*)

  class-or-interface-declaration:
    name: meta.class.ts
    begin: '(?<!\.|\$)\b(?:(export)\s+)?\b(?:(abstract)\s+)?\b(?:(class)|(interface))\b'
    beginCaptures:
      '1': { name: keyword.control.export.ts }
      '2': { name: storage.modifier.ts }
      '3': { name: storage.type.class.ts }
      '4': { name: storage.type.interface.ts }
    end: (?<=\})
    endCaptures:
      '1': { name: punctuation.definition.block.ts }
    patterns:
    - include: '#comment'
    - include: '#class-or-interface-heritage' # Must be before object-name to consume the "extends" keyword.
    - match: '[_$[:alpha:]][_$[:alnum:]]*'
      captures:
        '0': { name: 'entity.name.class.ts' }
    - include: '#type-parameters' # Must be applied after object-name e.g. interface KeyValuePair<K, V>
    - include: '#class-or-interface-body'

  class-or-interface-heritage:
    begin: '(?<!\.|\$)(?:\b(extends|implements)\b)(?!\$)'
    beginCaptures:
      '1': { name: storage.modifier.ts }
    end: (?=\{)
    endCaptures:
      '1': { name: punctuation.definition.block.ts }
    patterns:
    - include: '#comment'
    - include: '#class-or-interface-heritage'
    - include: '#type-parameters'
    - match: ([_$[:alpha:]][_$[:alnum:]]*)\s*(\.)
      captures:
        '1': { name: entity.name.type.module.ts }
        '2': { name: punctuation.accessor.ts }
    - match: '([_$[:alpha:]][_$[:alnum:]]*)'
      captures:
        '1': { name: entity.other.inherited-class.ts }

  class-or-interface-body:
    begin: \{
    beginCaptures:
      '0': { name: punctuation.definition.block.ts }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.block.ts }
    patterns:
    - include: "#string"
    - include: '#comment'
    - include: '#decorator'
    - include: '#field-declaration'
    - include: '#method-declaration'
    - include: '#indexer-declaration'
    - include: '#type-annotation'
    - include: '#variable-initializer'
    - include: '#access-modifier'
    - include: '#static-modifier'
    - include: '#property-accessor'
    - include: '#expression'
    - include: '#punctuation-comma'
    - include: '#punctuation-semicolon'

  type-object:
    name: meta.object.type.ts
    begin: \{
    beginCaptures:
      '0': { name: punctuation.definition.block.ts }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.block.ts }
    patterns:
    - include: '#type-object-members'

  type-object-members:
    patterns:
    - include: '#comment'
    - include: '#field-declaration'
    - include: '#method-declaration'
    - include: '#indexer-declaration'
    - include: '#type-annotation'
    - include: '#punctuation-comma'
    - include: '#punctuation-semicolon'

  field-declaration:
    name: meta.field.declaration.ts
    begin: (?<!\()(?:(?<!\.|\$)\b(readonly)\s+)?\s*((?:[_$[:alpha:]][_$[:alnum:]]*)|(?:\'[^']*\')|(?:\"[^"]*\"))\s*(\?\s*)?(?=(=|:))
    beginCaptures:
      '1': { name: storage.modifier.ts }
      '2': { name: variable.object.property.ts }
      '3': { name: keyword.operator.optional.ts }
    end: '(?=\}|;|,|$)|(?<=\})'
    patterns:
    - include: '#variable-initializer'
    - begin: \G
      end: (?!\G)(?=[};,=]|$)|(?<=\})
      patterns:
      - include: '#type-annotation'
      - include: '#string'
      - include: '#comment'

  method-declaration:
    name: meta.method.declaration.ts
    begin: (?<!\.|\$)(?:\b(abstract)\s+)?(?:\b(public|private|protected)\s+)?(?:\b(async)\s+)?(?:\b(get|set)\s+)?(?:(?:\b(?:(new)|(constructor))\b(?!\$))|(?:(\*)\s*)?(?=((([_$[:alpha:]][_$[:alnum:]]*)|(\'[^']*\')|(\"[^"]*\")|(\[[^\]]*\]))\s*(\??))?\s*[\(\<]))
    beginCaptures:
      '1': { name: storage.modifier.ts } # captures keyword (abstract)
      '2': { name: storage.modifier.ts } # captures keyword (public or private or protected)
      '3': { name: storage.modifier.async.ts } # captures keyword (async)
      '4': { name: storage.type.property.ts } # captures keyword (get|set)
      '5': { name: keyword.operator.new.ts } # captures keyword (new)
      '6': { name: storage.type.ts } # captures keyword (constructor)
      '7': { name: keyword.generator.asterisk.ts } # captures keyword (*)
    end: '(?=\}|;|,)|(?<=\})'
    patterns:
    - include: '#method-declaration-name'
    - include: '#comment'
    - include: '#type-parameters'
    - include: '#function-parameters'
    - include: '#return-type'
    - include: '#method-overload-declaration'
    - include: '#decl-block'

  method-overload-declaration:
    name: meta.method.overload.declaration.ts
    begin: (?<!\.|\$)(?:\b(abstract)\s+)?(?:\b(public|private|protected)\s+)?(?:\b(async)\s+)?(?:\b(get|set)\s+)?(?:(?:\b(?:(new)|(constructor))\b(?!\$))|(?:(\*)\s*)?(?=((([_$[:alpha:]][_$[:alnum:]]*)|(\'[^']*\')|(\"[^"]*\")|(\[[^\]]*\]))\s*(\??))?\s*[\(\<]))
    beginCaptures:
      '1': { name: storage.modifier.ts } # captures keyword (abstract)
      '2': { name: storage.modifier.ts } # captures keyword (public or private or protected)
      '3': { name: storage.modifier.async.ts } # captures keyword (async)
      '4': { name: storage.type.property.ts } # captures keyword (get|set)
      '5': { name: keyword.operator.new.ts } # captures keyword (new)
      '6': { name: storage.type.ts } # captures keyword (constructor)
      '7': { name: keyword.generator.asterisk.ts } # captures keyword (*)
    end: (?=\(|\<)
    patterns:
    - include: '#method-declaration-name'

  method-declaration-name:
    begin: \G(?!\(|\<)
    end: (?=\(|\<)
    patterns:
    - include: '#string'
    - include: '#array-literal'
    - name: entity.name.function.ts
      match: '[_$[:alpha:]][_$[:alnum:]]*'
    - name: keyword.operator.optional.ts
      match: \?
    
  indexer-declaration:
    name: meta.indexer.declaration.ts
    begin: (?:(?<!\.|\$)\b(readonly)\s*)?(\[)(?=\s*[_$[:alpha:]][_$[:alnum:]]*\s*[:\]])
    beginCaptures:
      '1': { name: storage.modifier.ts }
      '2': { name: meta.brace.square.ts }
    end: (\])\s*(\?\s*)?|$
    endCaptures:
      '1': { name: meta.brace.square.ts }
      '2': { name: keyword.operator.optional.ts }
    patterns:
    - include: '#type-annotation'
    - include: '#indexer-parameter'

  indexer-parameter:
    name: meta.indexer.parameter.ts
    match: ([_$[:alpha:]][_$[:alnum:]]*)
    captures:
      '1': { name: variable.parameter.ts}

  function-declaration:
    name: meta.function.ts
    begin: (?<!\.|\$)\b(?:(export)\s+)?(?:(async)\s+)?(function\b)(?:\s*(\*))?(?:(?:\s+|(?<=\*))([_$[:alpha:]][_$[:alnum:]]*))?\s*
    beginCaptures:
      '1': { name: keyword.control.export.ts }
      '2': { name: storage.modifier.async.ts }
      '3': { name: storage.type.function.ts }
      '4': { name: keyword.generator.asterisk.ts }
      '5': { name: entity.name.function.ts }
    end: (?=;|\})|(?<=\})
    patterns:
    - include: '#comment'
    - include: '#type-parameters'
    - include: '#function-parameters'
    - include: '#return-type'
    - include: '#function-overload-declaration'
    - include: '#decl-block'

  function-overload-declaration:
    name: meta.function.overload.ts
    match: (?<!\.|\$)\b(?:(export)\s+)?(?:(async)\s+)?(function\b)(?:\s*(\*))?(?:(?:\s+|(?<=\*))([_$[:alpha:]][_$[:alnum:]]*))?\s*
    captures:
      '1': { name: keyword.control.export.ts }
      '2': { name: storage.modifier.async.ts }
      '3': { name: storage.type.function.ts }
      '4': { name: keyword.generator.asterisk.ts }
      '5': { name: entity.name.function.ts }

  object-literal:
    name: meta.object-literal.ts
    begin: \{
    beginCaptures:
      '0': { name: punctuation.definition.block.ts }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.block.ts }
    patterns:
    - include: '#object-member'

  decl-block:
    name: meta.block.ts
    begin: \{
    beginCaptures:
      '0': { name: punctuation.definition.block.ts }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.block.ts }
    patterns:
    - include: '#statements'

  after-operator-block:
    name: meta.object-literal.ts
    begin: (?<=[=(:,\[?+!]|await|return|yield|throw|in|of|typeof|&&|\|\||\*)\s*(\{)
    beginCaptures:
      '1': { name: punctuation.definition.block.ts }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.block.ts }
    patterns:
    - include: '#object-member' 

  parameter-name:
    match: '(?:\s*\b(public|private|protected)\b\s+)?(\.\.\.)?\s*(?<!=|:)([_$[:alpha:]][_$[:alnum:]]*)\s*(\??)'
    captures:
      '1': { name: storage.modifier.ts }
      '2': { name: keyword.operator.spread.ts }
      '3': { name: variable.parameter.ts }
      '4': { name: keyword.operator.optional.ts }

  destructuring-parameter:
    patterns:
    - name: meta.parameter.object-binding-pattern.ts
      begin: (?<!=|:)\s*(\{)
      beginCaptures:
        '1': { name: punctuation.definition.binding-pattern.object.ts }
      end: \}
      endCaptures:
        '0': { name: punctuation.definition.binding-pattern.object.ts }
      patterns:
      - include: '#parameter-object-binding-element'
    - name: meta.paramter.array-binding-pattern.ts
      begin: (?<!=|:)\s*(\[)
      beginCaptures:
        '1': { name: punctuation.definition.binding-pattern.array.ts }
      end: \]
      endCaptures:
        '0': { name: punctuation.definition.binding-pattern.array.ts }
      patterns:
      - include: '#parameter-array-binding-element'

  parameter-object-binding-element:
    patterns:
    - include: '#comment'
    - begin: ([_$[:alpha:]][_$[:alnum:]]*)\s*(:)
      beginCaptures:
        '1': { name: variable.object.property.ts }
        '2': { name: punctuation.destructuring.ts }
      end: (?=,|\})
      patterns:
      - include: '#parameter-object-binding-pattern'
      - include: '#parameter-array-binding-pattern'
      - name: variable.parameter.ts
        match: ([_$[:alpha:]][_$[:alnum:]]*)
    - name: variable.parameter.ts
      match: ([_$[:alpha:]][_$[:alnum:]]*)
    - name: meta.delimiter.object.comma.ts
      match: ','

  parameter-array-binding-element:
    patterns:
    - include: '#comment'
    - include: '#parameter-object-binding-pattern'
    - include: '#parameter-array-binding-pattern'
    - name: variable.parameter.ts
      match: ([_$[:alpha:]][_$[:alnum:]]*)
    - name: meta.delimiter.object.comma.ts
      match: ','

  parameter-object-binding-pattern:
    begin: \{
    beginCaptures:
      '0': { name: punctuation.definition.binding-pattern.object.ts }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.binding-pattern.object.ts }
    patterns:
    - include: '#parameter-object-binding-element'

  parameter-array-binding-pattern:
    begin: \[
    beginCaptures:
      '0': { name: punctuation.definition.binding-pattern.array.ts }
    end: \]
    endCaptures:
      '0': { name: punctuation.definition.binding-pattern.array.ts }
    patterns:
    - include: '#parameter-array-binding-element'

  return-type:
    name: meta.return.type.ts
    begin: '(?<=\))\s*(:)'
    beginCaptures:
      '1': { name: keyword.operator.type.annotation.ts }
    end: (?<!:)((?=$)|(?=\{|;|//|\}))
    patterns:
    - include: '#comment'
    # Handle returning of object type specifically here so as to not confuse it with the start of function block
    - name: meta.object.type.ts
      begin: (?<=:)\s*(\{)
      beginCaptures:
        '1': { name: punctuation.definition.block.ts }
      end: \}
      endCaptures:
        '0': { name: punctuation.definition.block.ts }
      patterns:
      - include: '#type-object-members'
    - include: '#type-predicate-operator'
    - include: '#type'

  type-predicate-operator:
    name: keyword.operator.is.ts
    match: (?<!\.|\$)\bis\b(?!\$)

  type-annotation:
    name: meta.type.annotation.ts
    begin: ":"
    beginCaptures:
      '0': { name: keyword.operator.type.annotation.ts }
    end: (?=$|[,);\}\]]|//)|(?==[^>])|(?<=[\}>\]\)]|[_$[:alpha:]])\s*(?=\{)
    patterns:
    - include: '#comment'
    - include: '#type'

  type:
    name: meta.type.ts
    patterns:
    - include: '#comment'
    - include: '#string'
    - include: '#numeric-literal'
    - include: '#type-primitive'
    - include: '#type-builtin-literals'
    - include: '#typeof-operator'
    - include: '#type-parameters'
    - include: '#type-tuple'
    - include: '#type-object'
    - include: '#type-operator'
    - include: '#type-fn-type-parameters'
    - include: '#type-paren-or-function-parameters'
    - include: '#type-function-return-type'
    - include: '#type-name'

  function-parameters:
    name: meta.parameters.ts
    begin: \(
    beginCaptures:
      '0': { name: punctuation.definition.parameters.begin.ts }
    end: \)
    endCaptures:
      '0': { name: punctuation.definition.parameters.end.ts }
    patterns:
    - include: '#comment'
    - include: '#decorator'
    - include: '#destructuring-parameter'
    - include: '#parameter-name'
    - include: '#type-annotation'
    - include: '#variable-initializer'
    - name: punctuation.separator.parameter.ts
      match: ','

  type-primitive:
    name: support.type.primitive.ts
    match: '(?<!\.|\$)\b(string|number|boolean|symbol|any|void|never)\b(?!\$)'

  type-builtin-literals:
    name: support.type.builtin.ts
    match: '(?<!\.|\$)\b(this|true|false|undefined|null)\b(?!\$)'

  # Parenthesis can contain either types and function parameters
  # (number | string) or (param: number, param2: string)
  # and it can be nested, for example
  # (number | (param: number, param2: string) => void)
  type-paren-or-function-parameters:
    name: meta.type.paren.cover.ts
    begin: '\s*(\()'
    beginCaptures:
      '1': { name: meta.brace.round.ts }
    end: '\)'
    endCaptures:
      '0': { name: meta.brace.round.ts }
    patterns:
    - include: '#type'
    - include: '#function-parameters'

  type-fn-type-parameters:
    patterns:
    # constructor type
    - name: meta.type.constructor.ts
      match: (?<!\.|\$)\b(new)\b(?=\s*\<)
      captures:
        '1': { name: keyword.control.new.ts }
    - name: meta.type.constructor.ts
      begin: (?<!\.|\$)\b(new)\b\s*(?=\()
      beginCaptures:
        '1': { name: keyword.control.new.ts }
      end: (?<=\))
      patterns:
      - include: '#function-parameters'
    #type parameters followed by parenthesis
    - name: meta.type.function.ts
      begin: (?<=\>)\s*(?=\()
      end: (?<=\))
      patterns:
      - include: '#function-parameters'
    # () | (... | (param: | (param, | (param? | (param= | (param) =>
    - name: meta.type.function.ts
      begin: '(?x)(
        \s*
        (?=
          [(]\s*(
            ([)]) | 
            (\.\.\.) |
            ([_$[:alnum:]]+\s*(
              ([:,?=])|
              ([)]\s*=>)
            ))
          )
        )
      )'
      end: (?<=\))
      patterns:
      - include: '#function-parameters'

  type-operator:
    name: keyword.operator.type.ts
    match: '[&|]'

  type-function-return-type:
    name: meta.type.function.return.ts
    begin: '=>'
    beginCaptures:
      '0': { name: storage.type.function.arrow.ts }
    end: (?<!=>)(?=[,\]\)\{\}=;>]|//|$)
    patterns:
    - include: '#comment'
    # Handle returning of object type specifically here so as to not confuse it with the start of function block
    - name: meta.object.type.ts
      begin: (?<==>)\s*(\{)
      beginCaptures:
        '1': { name: punctuation.definition.block.ts }
      end: \}
      endCaptures:
        '0': { name: punctuation.definition.block.ts }
      patterns:
      - include: '#type-object-members'
    - include: '#type-predicate-operator'
    - include: '#type'

  type-tuple:
    name: meta.type.tuple.ts
    begin: \[
    beginCaptures:
      '0': { name: meta.brace.square.ts }
    end: \]
    endCaptures:
      '0': { name: meta.brace.square.ts }
    patterns:
    - include: '#type'
    - include: '#punctuation-comma'

  type-name:
    patterns:
    - match: ([_$[:alpha:]][_$[:alnum:]]*)\s*(\.)
      captures:
        '1': { name: entity.name.type.module.ts }
        '2': { name: punctuation.accessor.ts }
    - name: entity.name.type.ts
      match: '[_$[:alpha:]][_$[:alnum:]]*'

  type-parameters:
    name: meta.type.parameters.ts
    begin: '(<)'
    beginCaptures:
      '1': { name: punctuation.definition.typeparameters.begin.ts }
    end: '(?=$)|(>)'
    endCaptures:
      '1': { name: punctuation.definition.typeparameters.end.ts }
    patterns:
    - include: '#comment'
    - name: storage.modifier.ts
      match: '(?<!\.|\$)\b(extends)\b(?!\$)'
    - include: '#type'
    - include: '#punctuation-comma'

  variable-initializer:
    begin: (?<!=|!)(=)(?!=)
    beginCaptures:
      '1': { name: keyword.operator.assignment.ts }
    end: (?=$|[,);}])
    patterns:
      - include: '#expression'

  for-loop:
    begin: (?<!\.|\$)\b(for)\s*(\()
    beginCaptures:
      '1': { name: keyword.control.loop.ts }
      '2': { name: meta.brace.round.ts }
    end: \)
    endCaptures:
      '0': { name: meta.brace.round.ts }
    patterns:
    - include: '#var-expr'
    - include: '#expression'
    - include: '#punctuation-semicolon'

  switch-expression:
    name: switch-expression.expr.ts
    begin: (?<!\.|\$)\b(switch)\s*(\()
    beginCaptures:
      '1': { name: keyword.control.switch.ts }
      '2': { name: meta.brace.round.ts }
    end: \)
    endCaptures:
      '0': { name: meta.brace.round.ts }
    patterns:
    - include: '#expression'

  switch-block:
    name: switch-block.expr.ts
    begin: '{'
    beginCaptures:
      '0': { name: punctuation.definition.block.ts }
    end: (?=\})
    patterns:
    - include: '#case-clause'
    - include: '#statements'

  case-clause:
    name: case-clause.expr.ts
    begin: '(?<!\.|\$)\b(case|default(?=:))\b(?!\$)'
    beginCaptures:
      '1': { name: keyword.control.switch.ts }
    end: ':'
    patterns:
    - include: '#expression'

  switch-statement:
    name: switch-statement.expr.ts
    begin: (?<!\.|\$)(?=\bswitch\s*\()
    end: '}'
    endCaptures:
      '0': {name: punctuation.definition.block.ts}      
    patterns:
    - include: '#switch-expression'
    - include: '#switch-block'

  support-objects:
    patterns:
    - name: variable.language.arguments.ts
      match: (?<!\.|\$)\b(arguments)\b(?!\$)
    # builtins
    - name: support.class.builtin.ts
      match: (?x)(?<!\.|\$)\b(Array|ArrayBuffer|Atomics|Boolean|DataView|Date|Float32Array|Float64Array|Function|Generator
        |GeneratorFunction|Int8Array|Int16Array|Int32Array|Intl|Map|Number|Object|Promise|Proxy
        |Reflect|RegExp|Set|SharedArrayBuffer|SIMD|String|Symbol|TypedArray
        |Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|WeakMap|WeakSet)\b(?!\$)
    - name: support.class.error.ts
      match: (?<!\.|\$)\b((Eval|Internal|Range|Reference|Syntax|Type|URI)?Error)\b(?!\$)
    # known builtin function calls
    - name: support.function.ts
      match: (?x)(?<!\.|\$)\b(clear(Interval|Timeout)|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|
        isFinite|isNaN|parseFloat|parseInt|require|set(Interval|Timeout)|super|unescape|uneval)(?=\s*\() 
    # Math
    - match: |-
        (?x)(?<!\.|\$)\b(Math)(?:\s*(\.)\s*(?:
          (abs|acos|acosh|asin|asinh|atan|atan2|atanh|cbrt|ceil|clz32|cos|cosh|exp|
          expm1|floor|fround|hypot|imul|log|log10|log1p|log2|max|min|pow|random|
          round|sign|sin|sinh|sqrt|tan|tanh|trunc)
          |
          (E|LN10|LN2|LOG10E|LOG2E|PI|SQRT1_2|SQRT2)))?\b(?!\$)
      captures:
        '1': { name: support.constant.math.ts }
        '2': { name: punctuation.accessor.ts }
        '3': { name: support.function.math.ts }
        '4': { name: support.constant.property.math.ts }
    # console
    - match: |-
        (?x)(?<!\.|\$)\b(console)(?:\s*(\.)\s*(
          assert|clear|count|debug|dir|error|group|groupCollapsed|groupEnd|info|log
          |profile|profileEnd|table|time|timeEnd|timeStamp|trace|warn))?\b(?!\$)
      captures:
        '1': { name: support.class.console.ts }
        '2': { name: punctuation.accessor.ts }
        '3': { name: support.function.console.ts }
    # JSON
    - match: (?<!\.|\$)\b(JSON)(?:\s*(\.)\s*(parse|stringify))?\b(?!\$)
      captures:
        '1': { name: support.constant.json.ts }
        '2': { name: punctuation.accessor.ts }
        '3': { name: support.function.json.ts }
    # DOM
    - match: |-
        (?x) (\.) \s* (?:
          (constructor|length|prototype|__proto__) 
          |
          (EPSILON|MAX_SAFE_INTEGER|MAX_VALUE|MIN_SAFE_INTEGER|MIN_VALUE|NEGATIVE_INFINITY|POSITIVE_INFINITY))\b(?!\$)
      captures: 
        '1': { name: punctuation.accessor.ts }
        '2': { name: support.variable.property.ts }
        '3': { name: support.constant.ts }
    - match: |-
        (?x) (?<!\.|\$) \b (?:
          (document|event|navigator|performance|screen|window) 
          |
          (AnalyserNode|ArrayBufferView|Attr|AudioBuffer|AudioBufferSourceNode|AudioContext|AudioDestinationNode|AudioListener
          |AudioNode|AudioParam|BatteryManager|BeforeUnloadEvent|BiquadFilterNode|Blob|BufferSource|ByteString|CSS|CSSConditionRule
          |CSSCounterStyleRule|CSSGroupingRule|CSSMatrix|CSSMediaRule|CSSPageRule|CSSPrimitiveValue|CSSRule|CSSRuleList|CSSStyleDeclaration
          |CSSStyleRule|CSSStyleSheet|CSSSupportsRule|CSSValue|CSSValueList|CanvasGradient|CanvasImageSource|CanvasPattern
          |CanvasRenderingContext2D|ChannelMergerNode|ChannelSplitterNode|CharacterData|ChromeWorker|CloseEvent|Comment|CompositionEvent
          |Console|ConvolverNode|Coordinates|Credential|CredentialsContainer|Crypto|CryptoKey|CustomEvent|DOMError|DOMException
          |DOMHighResTimeStamp|DOMImplementation|DOMString|DOMStringList|DOMStringMap|DOMTimeStamp|DOMTokenList|DataTransfer
          |DataTransferItem|DataTransferItemList|DedicatedWorkerGlobalScope|DelayNode|DeviceProximityEvent|DirectoryEntry
          |DirectoryEntrySync|DirectoryReader|DirectoryReaderSync|Document|DocumentFragment|DocumentTouch|DocumentType|DragEvent
          |DynamicsCompressorNode|Element|Entry|EntrySync|ErrorEvent|Event|EventListener|EventSource|EventTarget|FederatedCredential
          |FetchEvent|File|FileEntry|FileEntrySync|FileException|FileList|FileReader|FileReaderSync|FileSystem|FileSystemSync
          |FontFace|FormData|GainNode|Gamepad|GamepadButton|GamepadEvent|Geolocation|GlobalEventHandlers|HTMLAnchorElement
          |HTMLAreaElement|HTMLAudioElement|HTMLBRElement|HTMLBaseElement|HTMLBodyElement|HTMLButtonElement|HTMLCanvasElement
          |HTMLCollection|HTMLContentElement|HTMLDListElement|HTMLDataElement|HTMLDataListElement|HTMLDialogElement|HTMLDivElement
          |HTMLDocument|HTMLElement|HTMLEmbedElement|HTMLFieldSetElement|HTMLFontElement|HTMLFormControlsCollection|HTMLFormElement
          |HTMLHRElement|HTMLHeadElement|HTMLHeadingElement|HTMLHtmlElement|HTMLIFrameElement|HTMLImageElement|HTMLInputElement
          |HTMLKeygenElement|HTMLLIElement|HTMLLabelElement|HTMLLegendElement|HTMLLinkElement|HTMLMapElement|HTMLMediaElement
          |HTMLMetaElement|HTMLMeterElement|HTMLModElement|HTMLOListElement|HTMLObjectElement|HTMLOptGroupElement|HTMLOptionElement
          |HTMLOptionsCollection|HTMLOutputElement|HTMLParagraphElement|HTMLParamElement|HTMLPreElement|HTMLProgressElement
          |HTMLQuoteElement|HTMLScriptElement|HTMLSelectElement|HTMLShadowElement|HTMLSourceElement|HTMLSpanElement|HTMLStyleElement
          |HTMLTableCaptionElement|HTMLTableCellElement|HTMLTableColElement|HTMLTableDataCellElement|HTMLTableElement|HTMLTableHeaderCellElement
          |HTMLTableRowElement|HTMLTableSectionElement|HTMLTextAreaElement|HTMLTimeElement|HTMLTitleElement|HTMLTrackElement
          |HTMLUListElement|HTMLUnknownElement|HTMLVideoElement|HashChangeEvent|History|IDBCursor|IDBCursorWithValue|IDBDatabase
          |IDBEnvironment|IDBFactory|IDBIndex|IDBKeyRange|IDBMutableFile|IDBObjectStore|IDBOpenDBRequest|IDBRequest|IDBTransaction
          |IDBVersionChangeEvent|IIRFilterNode|IdentityManager|ImageBitmap|ImageBitmapFactories|ImageData|Index|InputDeviceCapabilities
          |InputEvent|InstallEvent|InstallTrigger|KeyboardEvent|LinkStyle|LocalFileSystem|LocalFileSystemSync|Location|MIDIAccess
          |MIDIConnectionEvent|MIDIInput|MIDIInputMap|MIDIOutputMap|MediaElementAudioSourceNode|MediaError|MediaKeyMessageEvent
          |MediaKeySession|MediaKeyStatusMap|MediaKeySystemAccess|MediaKeySystemConfiguration|MediaKeys|MediaRecorder|MediaStream
          |MediaStreamAudioDestinationNode|MediaStreamAudioSourceNode|MessageChannel|MessageEvent|MessagePort|MouseEvent
          |MutationObserver|MutationRecord|NamedNodeMap|Navigator|NavigatorConcurrentHardware|NavigatorGeolocation|NavigatorID
          |NavigatorLanguage|NavigatorOnLine|Node|NodeFilter|NodeIterator|NodeList|NonDocumentTypeChildNode|Notification
          |OfflineAudioCompletionEvent|OfflineAudioContext|OscillatorNode|PageTransitionEvent|PannerNode|ParentNode|PasswordCredential
          |Path2D|PaymentAddress|PaymentRequest|PaymentResponse|Performance|PerformanceEntry|PerformanceFrameTiming|PerformanceMark
          |PerformanceMeasure|PerformanceNavigation|PerformanceNavigationTiming|PerformanceObserver|PerformanceObserverEntryList
          |PerformanceResourceTiming|PerformanceTiming|PeriodicSyncEvent|PeriodicWave|Plugin|Point|PointerEvent|PopStateEvent
          |PortCollection|Position|PositionError|PositionOptions|PresentationConnectionClosedEvent|PresentationConnectionList
          |PresentationReceiver|ProcessingInstruction|ProgressEvent|PromiseRejectionEvent|PushEvent|PushRegistrationManager
          |RTCCertificate|RTCConfiguration|RTCPeerConnection|RTCSessionDescriptionCallback|RTCStatsReport|RadioNodeList|RandomSource
          |Range|ReadableByteStream|RenderingContext|SVGAElement|SVGAngle|SVGAnimateColorElement|SVGAnimateElement|SVGAnimateMotionElement
          |SVGAnimateTransformElement|SVGAnimatedAngle|SVGAnimatedBoolean|SVGAnimatedEnumeration|SVGAnimatedInteger|SVGAnimatedLength
          |SVGAnimatedLengthList|SVGAnimatedNumber|SVGAnimatedNumberList|SVGAnimatedPoints|SVGAnimatedPreserveAspectRatio
          |SVGAnimatedRect|SVGAnimatedString|SVGAnimatedTransformList|SVGAnimationElement|SVGCircleElement|SVGClipPathElement
          |SVGCursorElement|SVGDefsElement|SVGDescElement|SVGElement|SVGEllipseElement|SVGEvent|SVGFilterElement|SVGFontElement
          |SVGFontFaceElement|SVGFontFaceFormatElement|SVGFontFaceNameElement|SVGFontFaceSrcElement|SVGFontFaceUriElement
          |SVGForeignObjectElement|SVGGElement|SVGGlyphElement|SVGGradientElement|SVGHKernElement|SVGImageElement|SVGLength
          |SVGLengthList|SVGLineElement|SVGLinearGradientElement|SVGMPathElement|SVGMaskElement|SVGMatrix|SVGMissingGlyphElement
          |SVGNumber|SVGNumberList|SVGPathElement|SVGPatternElement|SVGPoint|SVGPolygonElement|SVGPolylineElement|SVGPreserveAspectRatio
          |SVGRadialGradientElement|SVGRect|SVGRectElement|SVGSVGElement|SVGScriptElement|SVGSetElement|SVGStopElement|SVGStringList
          |SVGStylable|SVGStyleElement|SVGSwitchElement|SVGSymbolElement|SVGTRefElement|SVGTSpanElement|SVGTests|SVGTextElement
          |SVGTextPositioningElement|SVGTitleElement|SVGTransform|SVGTransformList|SVGTransformable|SVGUseElement|SVGVKernElement
          |SVGViewElement|ServiceWorker|ServiceWorkerContainer|ServiceWorkerGlobalScope|ServiceWorkerRegistration|ServiceWorkerState
          |ShadowRoot|SharedWorker|SharedWorkerGlobalScope|SourceBufferList|StereoPannerNode|Storage|StorageEvent|StyleSheet
          |StyleSheetList|SubtleCrypto|SyncEvent|Text|TextMetrics|TimeEvent|TimeRanges|Touch|TouchEvent|TouchList|Transferable
          |TreeWalker|UIEvent|USVString|VRDisplayCapabilities|ValidityState|WaveShaperNode|WebGL|WebGLActiveInfo|WebGLBuffer
          |WebGLContextEvent|WebGLFramebuffer|WebGLProgram|WebGLRenderbuffer|WebGLRenderingContext|WebGLShader|WebGLShaderPrecisionFormat
          |WebGLTexture|WebGLTimerQueryEXT|WebGLTransformFeedback|WebGLUniformLocation|WebGLVertexArrayObject|WebGLVertexArrayObjectOES
          |WebSocket|WebSockets|WebVTT|WheelEvent|Window|WindowBase64|WindowEventHandlers|WindowTimers|Worker|WorkerGlobalScope
          |WorkerLocation|WorkerNavigator|XMLHttpRequest|XMLHttpRequestEventTarget|XMLSerializer|XPathExpression|XPathResult
          |XSLTProcessor))\b(?!\$)
      captures:
        '1': { name: support.variable.dom.ts }
        '2': { name: support.class.dom.ts }
    - match: |-
        (?x) (\.) \s* (?:
          (ATTRIBUTE_NODE|CDATA_SECTION_NODE|COMMENT_NODE|DOCUMENT_FRAGMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE
          |DOMSTRING_SIZE_ERR|ELEMENT_NODE|ENTITY_NODE|ENTITY_REFERENCE_NODE|HIERARCHY_REQUEST_ERR|INDEX_SIZE_ERR
          |INUSE_ATTRIBUTE_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR
          |NOT_SUPPORTED_ERR|NOTATION_NODE|PROCESSING_INSTRUCTION_NODE|TEXT_NODE|WRONG_DOCUMENT_ERR)
          |
          (_content|[xyz]|abbr|above|accept|acceptCharset|accessKey|action|align|[av]Link(?:color)?|all|alt|anchors|appCodeName
          |appCore|applets|appMinorVersion|appName|appVersion|archive|areas|arguments|attributes|availHeight|availLeft|availTop
          |availWidth|axis|background|backgroundColor|backgroundImage|below|bgColor|body|border|borderBottomWidth|borderColor
          |borderLeftWidth|borderRightWidth|borderStyle|borderTopWidth|borderWidth|bottom|bufferDepth|callee|caller|caption
          |cellPadding|cells|cellSpacing|ch|characterSet|charset|checked|childNodes|chOff|cite|classes|className|clear
          |clientInformation|clip|clipBoardData|closed|code|codeBase|codeType|color|colorDepth|cols|colSpan|compact|complete
          |components|content|controllers|cookie|cookieEnabled|cords|cpuClass|crypto|current|data|dateTime|declare|defaultCharset
          |defaultChecked|defaultSelected|defaultStatus|defaultValue|defaultView|defer|description|dialogArguments|dialogHeight
          |dialogLeft|dialogTop|dialogWidth|dir|directories|disabled|display|docmain|doctype|documentElement|elements|embeds
          |enabledPlugin|encoding|enctype|entities|event|expando|external|face|fgColor|filename|firstChild|fontFamily|fontSize
          |fontWeight|form|formName|forms|frame|frameBorder|frameElement|frames|hasFocus|hash|headers|height|history|host
          |hostname|href|hreflang|hspace|htmlFor|httpEquiv|id|ids|ignoreCase|images|implementation|index|innerHeight|innerWidth
          |input|isMap|label|lang|language|lastChild|lastIndex|lastMatch|lastModified|lastParen|layer[sXY]|left|leftContext
          |lineHeight|link|linkColor|links|listStyleType|localName|location|locationbar|longDesc|lowsrc|lowSrc|marginBottom
          |marginHeight|marginLeft|marginRight|marginTop|marginWidth|maxLength|media|menubar|method|mimeTypes|multiline|multiple
          |name|nameProp|namespaces|namespaceURI|next|nextSibling|nodeName|nodeType|nodeValue|noHref|noResize|noShade|notationName
          |notations|noWrap|object|offscreenBuffering|onLine|onreadystatechange|opener|opsProfile|options|oscpu|outerHeight
          |outerWidth|ownerDocument|paddingBottom|paddingLeft|paddingRight|paddingTop|page[XY]|page[XY]Offset|parent|parentLayer
          |parentNode|parentWindow|pathname|personalbar|pixelDepth|pkcs11|platform|plugins|port|prefix|previous|previousDibling
          |product|productSub|profile|profileend|prompt|prompter|protocol|publicId|readOnly|readyState|referrer|rel|responseText
          |responseXML|rev|right|rightContext|rowIndex|rows|rowSpan|rules|scheme|scope|screen[XY]|screenLeft|screenTop|scripts
          |scrollbars|scrolling|sectionRowIndex|security|securityPolicy|selected|selectedIndex|selection|self|shape|siblingAbove
          |siblingBelow|size|source|specified|standby|start|status|statusbar|statusText|style|styleSheets|suffixes|summary
          |systemId|systemLanguage|tagName|tags|target|tBodies|text|textAlign|textDecoration|textIndent|textTransform|tFoot|tHead
          |title|toolbar|top|type|undefined|uniqueID|updateInterval|URL|URLUnencoded|useMap|userAgent|userLanguage|userProfile
          |vAlign|value|valueType|vendor|vendorSub|version|visibility|vspace|whiteSpace|width|X[MS]LDocument|zIndex))\b(?!\$|\s*(<([^<>]|\<[^<>]+\>)+>\s*)?\()
      captures:
        '1': { name: punctuation.accessor.ts }
        '2': { name: support.constant.dom.ts }
        '3': { name: support.variable.property.dom.ts }
    # Node
    - name: support.class.node.ts
      match: |-
        (?x)(?<!\.|\$)\b(Buffer|EventEmitter|Server|Pipe|Socket|REPLServer|ReadStream|WriteStream|Stream
          |Inflate|Deflate|InflateRaw|DeflateRaw|GZip|GUnzip|Unzip|Zip)\b(?!\$)
    - name: support.module.node.ts
      match: |-
        (?x)(?<!\.|\$)\b(assert|buffer|child_process|cluster|constants|crypto|dgram|dns|domain|events|fs|http|https|net
          |os|path|punycode|querystring|readline|repl|stream|string_decoder|timers|tls|tty|url|util|vm|zlib)\b(?!\$)
    - match: |-
        (?x)(?<!\.|\$)\b(process)(?:(\.)(?:
          (arch|argv|config|connected|env|execArgv|execPath|exitCode|mainModule|pid|platform|release|stderr|stdin|stdout|title|version|versions)
          |
          (abort|chdir|cwd|disconnect|exit|[sg]ete?[gu]id|send|[sg]etgroups|initgroups|kill|memoryUsage|nextTick|umask|uptime|hrtime)
        ))?\b(?!\$)
      captures:
        '1': { name: support.variable.object.process.ts }
        '2': { name: punctuation.accessor.ts }
        '3': { name: support.variable.property.process.ts }
        '4': { name: support.function.process.ts }
    - match: (?<!\.|\$)\b(?:(exports)|(module)(?:(\.)(exports|id|filename|loaded|parent|children))?)\b(?!\$)
      captures:
        '1': { name: support.type.object.module.ts }
        '2': { name: support.type.object.module.ts }
        '3': { name: punctuation.accessor.ts }
        '4': { name: support.type.object.module.ts }
    - name: support.variable.object.node.ts
      match: (?<!\.|\$)\b(global|GLOBAL|root|__dirname|__filename)\b(?!\$)
    # method calls
    - match: |-
       (?x) (\.) \s* 
       (?:
        (on(?:Rowsinserted|Rowsdelete|Rowenter|Rowexit|Resize|Resizestart|Resizeend|Reset|
          Readystatechange|Mouseout|Mouseover|Mousedown|Mouseup|Mousemove|
          Before(?:cut|deactivate|unload|update|paste|print|editfocus|activate)|
          Blur|Scrolltop|Submit|Select|Selectstart|Selectionchange|Hover|Help|
          Change|Contextmenu|Controlselect|Cut|Cellchange|Clock|Close|Deactivate|
          Datasetchanged|Datasetcomplete|Dataavailable|Drop|Drag|Dragstart|Dragover|
          Dragdrop|Dragenter|Dragend|Dragleave|Dblclick|Unload|Paste|Propertychange|Error|
          Errorupdate|Keydown|Keyup|Keypress|Focus|Load|Activate|Afterupdate|Afterprint|Abort)
        ) |
        (shift|showModelessDialog|showModalDialog|showHelp|scroll|scrollX|scrollByPages|
          scrollByLines|scrollY|scrollTo|stop|strike|sizeToContent|sidebar|signText|sort|
          sup|sub|substr|substring|splice|split|send|set(?:Milliseconds|Seconds|Minutes|Hours|
          Month|Year|FullYear|Date|UTC(?:Milliseconds|Seconds|Minutes|Hours|Month|FullYear|Date)|
          Time|Hotkeys|Cursor|ZOptions|Active|Resizable|RequestHeader)|search|slice|
          savePreferences|small|home|handleEvent|navigate|char|charCodeAt|charAt|concat|
          contextual|confirm|compile|clear|captureEvents|call|createStyleSheet|createPopup|
          createEventObject|to(?:GMTString|UTCString|String|Source|UpperCase|LowerCase|LocaleString)|
          test|taint|taintEnabled|indexOf|italics|disableExternalCapture|dump|detachEvent|unshift|
          untaint|unwatch|updateCommands|join|javaEnabled|pop|push|plugins.refresh|paddings|parse|
          print|prompt|preference|enableExternalCapture|exec|execScript|valueOf|UTC|find|file|
          fileModifiedDate|fileSize|fileCreatedDate|fileUpdatedDate|fixed|fontsize|fontcolor|
          forward|fromCharCode|watch|link|load|lastIndexOf|anchor|attachEvent|atob|apply|alert|
          abort|routeEvents|resize|resizeBy|resizeTo|recalc|returnValue|replace|reverse|reload|
          releaseCapture|releaseEvents|go|get(?:Milliseconds|Seconds|Minutes|Hours|Month|Day|Year|FullYear|
          Time|Date|TimezoneOffset|UTC(?:Milliseconds|Seconds|Minutes|Hours|Day|Month|FullYear|Date)|
          Attention|Selection|ResponseHeader|AllResponseHeaders)|moveBy|moveBelow|moveTo|
          moveToAbsolute|moveAbove|mergeAttributes|match|margins|btoa|big|bold|borderWidths|blink|back
        ) |
        (acceptNode|add|addEventListener|addTextTrack|adoptNode|after|animate|append|
          appendChild|appendData|before|blur|canPlayType|captureStream|
          caretPositionFromPoint|caretRangeFromPoint|checkValidity|clear|click|
          cloneContents|cloneNode|cloneRange|close|closest|collapse|
          compareBoundaryPoints|compareDocumentPosition|comparePoint|contains|
          convertPointFromNode|convertQuadFromNode|convertRectFromNode|createAttribute|
          createAttributeNS|createCaption|createCDATASection|createComment|
          createContextualFragment|createDocument|createDocumentFragment|
          createDocumentType|createElement|createElementNS|createEntityReference|
          createEvent|createExpression|createHTMLDocument|createNodeIterator|
          createNSResolver|createProcessingInstruction|createRange|createShadowRoot|
          createTBody|createTextNode|createTFoot|createTHead|createTreeWalker|delete|
          deleteCaption|deleteCell|deleteContents|deleteData|deleteRow|deleteTFoot|
          deleteTHead|detach|disconnect|dispatchEvent|elementFromPoint|elementsFromPoint|
          enableStyleSheetsForSet|entries|evaluate|execCommand|exitFullscreen|
          exitPointerLock|expand|extractContents|fastSeek|firstChild|focus|forEach|get|
          getAll|getAnimations|getAttribute|getAttributeNames|getAttributeNode|
          getAttributeNodeNS|getAttributeNS|getBoundingClientRect|getBoxQuads|
          getClientRects|getContext|getDestinationInsertionPoints|getElementById|
          getElementsByClassName|getElementsByName|getElementsByTagName|
          getElementsByTagNameNS|getItem|getNamedItem|getSelection|getStartDate|
          getVideoPlaybackQuality|has|hasAttribute|hasAttributeNS|hasAttributes|
          hasChildNodes|hasFeature|hasFocus|importNode|initEvent|insertAdjacentElement|
          insertAdjacentHTML|insertAdjacentText|insertBefore|insertCell|insertData|
          insertNode|insertRow|intersectsNode|isDefaultNamespace|isEqualNode|
          isPointInRange|isSameNode|item|key|keys|lastChild|load|lookupNamespaceURI|
          lookupPrefix|matches|move|moveAttribute|moveAttributeNode|moveChild|
          moveNamedItem|namedItem|nextNode|nextSibling|normalize|observe|open|
          parentNode|pause|play|postMessage|prepend|preventDefault|previousNode|
          previousSibling|probablySupportsContext|queryCommandEnabled|
          queryCommandIndeterm|queryCommandState|queryCommandSupported|queryCommandValue|
          querySelector|querySelectorAll|registerContentHandler|registerElement|
          registerProtocolHandler|releaseCapture|releaseEvents|remove|removeAttribute|
          removeAttributeNode|removeAttributeNS|removeChild|removeEventListener|
          removeItem|replace|replaceChild|replaceData|replaceWith|reportValidity|
          requestFullscreen|requestPointerLock|reset|scroll|scrollBy|scrollIntoView|
          scrollTo|seekToNextFrame|select|selectNode|selectNodeContents|set|setAttribute|
          setAttributeNode|setAttributeNodeNS|setAttributeNS|setCapture|
          setCustomValidity|setEnd|setEndAfter|setEndBefore|setItem|setNamedItem|
          setRangeText|setSelectionRange|setSinkId|setStart|setStartAfter|setStartBefore|
          slice|splitText|stepDown|stepUp|stopImmediatePropagation|stopPropagation|
          submit|substringData|supports|surroundContents|takeRecords|terminate|toBlob|
          toDataURL|toggle|toString|values|write|writeln
        )
       )(?=\s*\()
      captures:
        '1': { name: punctuation.accessor.ts }
        '2': { name: support.function.event-handler.ts }
        '3': { name: support.function.ts }
        '4': { name: support.function.dom.ts }

  function-call:
    begin: (?:(\.)\s*)?([_$[:alpha:]][_$[:alnum:]]*)\s*(?=(<([^<>]|\<[^<>]+\>)+>\s*)?\()
    beginCaptures:
      '1': { name: punctuation.accessor.ts }
      '2': { name: entity.name.function.ts }
    end: (?=\()
    patterns:
    - include: '#comment'
    - name: meta.type.parameters.ts
      begin: \<
      beginCaptures:
        '0': { name: punctuation.definition.typeparameters.begin.ts }
      end: \>
      endCaptures:
        '0': { name: punctuation.definition.typeparameters.end.ts }
      patterns:
      - include: '#type'
      - include: '#punctuation-comma'

  identifiers:
    patterns:
    # class
    - name: support.class.ts
      match: ([_$[:alpha:]][_$[:alnum:]]*)(?=\s*\.\s*prototype\b(?!\$))
    # object properties
    - match: |-
        (?x)(\.)\s*(?:
          ([[:upper:]][_$[:digit:][:upper:]]*) |
          ([_$[:alpha:]][_$[:alnum:]]*)
        )(?=\s*\.\s*[_$[:alpha:]][_$[:alnum:]]*)
      captures:
        '1': { name: punctuation.accessor.ts }
        '2': { name: constant.other.object.property.ts }
        '3': { name: variable.other.object.property.ts }
    # function and method assignment
    - match: (?x)(?:(\.)\s*)?([_$[:alpha:]][_$[:alnum:]]*)(?=\s*=\s*(
        (async\s+)|(function\s+)|
        ([_$[:alpha:]][_$[:alnum:]]*\s*=>)|
        ((<([^<>]|\<[^<>]+\>)+>\s*)?\(([^()]|\([^()]*\))*\)(\s*:\s*(.)*)?\s*=>)))
      captures:
        '1': { name: punctuation.accessor.ts }
        '2': { name: entity.name.function.ts }
    # const properties
    - match: (\.)\s*([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])
      captures:
        '1': { name: punctuation.accessor.ts }
        '2': { name: constant.other.property.ts }
    # properties
    - match: (\.)\s*([_$[:alpha:]][_$[:alnum:]]*)
      captures:
        '1': { name: punctuation.accessor.ts }
        '2': { name: variable.other.property.ts }
    # objects
    - match: |-
        (?x)(?:
          ([[:upper:]][_$[:digit:][:upper:]]*) |
          ([_$[:alpha:]][_$[:alnum:]]*)
        )(?=\s*\.\s*[_$[:alpha:]][_$[:alnum:]]*)
      captures:
        '1': { name: constant.other.object.ts }
        '2': { name: variable.other.object.ts }
    # const
    - name: constant.other.ts
      match: ([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])
    # vars
    - name: variable.other.readwrite.ts
      match: '[_$[:alpha:]][_$[:alnum:]]*'

  cast:
    name: cast.expr.ts
    # We need to differentiate between the relational '<' operator and the beginning of a type assertion/cast using the surrounding context.
    # If '<' is preceeded by 'return', 'throw', 'yield', or 'await', it's most likely a type assertion
    # If '=', '(', ',', ':', or '>' are followed by a '<', it is also likely a type assertion as otherwise it would be a syntax error
    # '<=' and '<<=' are cannot be type assertions, as they are assignment operators.
    begin: '(?:(?<=return|throw|yield|await|default|[=(,:>*]))\s*(<)(?!<?\=)'
    beginCaptures:
      '1': { name: meta.brace.angle.ts }
    end: '>'
    endCaptures:
      '0': { name: meta.brace.angle.ts }
    patterns:
    - include: '#type'

  new-expr:
    name: new.expr.ts
    begin: '(?<!\.|\$)\b(new)\b(?!\$)'
    beginCaptures:
      '1': { name: keyword.operator.new.ts }
    # new-expr ends just before any type or call arguments. Type arguments will be picked up by #cast.
    end: '(?=[(;),]|$|((?<!\.|\$)\bnew\b(?!\$)))'
    patterns:
    - include: '#type'

  object-member:
    patterns:
    - include: '#comment'
    - include: '#method-declaration'
    - name: meta.object.member.ts
      begin: (?=(?:(?:\'[^']*\')|(?:\"[^"]*\")|(?:\[[^\]]*\]))\s*:)
      end: (?=,|\})
      patterns:
      - name: meta.object-literal.key.ts
        begin: (?=(?:(?:\'[^']*\')|(?:\"[^"]*\")|(?:\[[^\]]*\]))\s*:)
        end: ':'
        endCaptures:
          '0': { name: punctuation.separator.key-value.ts }
        patterns:
        - include: '#string'
        - include: '#array-literal'
      - include: '#expression'
    - name: meta.object.member.ts
      begin: (?x)(?:([_$[:alpha:]][_$[:alnum:]]*)\s*(:)(?=\s*(
        (async\s+)|(function\s+)|
        ([_$[:alpha:]][_$[:alnum:]]*\s*=>)|
        ((<([^<>]|\<[^<>]+\>)+>\s*)?\(([^()]|\([^()]*\))*\)(\s*:\s*(.)*)?\s*=>))))
      beginCaptures:
        '0': { name: meta.object-literal.key.ts }
        '1': { name: entity.name.function.ts }
        '2': { name: punctuation.separator.key-value.ts }
      end: (?=,|\})
      patterns:
      - include: '#expression'
    - name: meta.object.member.ts
      begin: (?:[_$[:alpha:]][_$[:alnum:]]*)\s*(:)
      beginCaptures:
        '0': { name: meta.object-literal.key.ts }
        '1': { name: punctuation.separator.key-value.ts }
      end: (?=,|\})
      patterns:
      - include: '#expression'
    - name: meta.object.member.ts
      match: ([_$[:alpha:]][_$[:alnum:]]*)\s*(?=,|\})
      captures:
        '1': { name: variable.other.readwrite.ts }
    - include: '#punctuation-comma'

  expression-operator:
    patterns:
    - name: keyword.control.flow.ts
      match: (?<!\.|\$)\b(await)\b(?!\$)
    - name: keyword.operator.delete.ts
      match: (?<!\.|\$)\bdelete\b(?!\$)
    - name: keyword.operator.in.ts
      match: (?<!\.|\$)\bin\b(?!\$)
    - name: keyword.operator.of.ts
      match: (?<!\.|\$)\bof\b(?!\$)
    - name: keyword.operator.instanceof.ts
      match: (?<!\.|\$)\binstanceof\b(?!\$)
    - name: keyword.operator.new.ts
      match: (?<!\.|\$)\bnew\b(?!\$)
    - include: '#typeof-operator'
    - name: keyword.operator.void.ts
      match: (?<!\.|\$)\bvoid\b(?!\$)
    - begin: (?<!\.|\$)\bas\b(?!\$)
      beginCaptures:
        '0': { name: keyword.control.as.ts }
      end: (?=$|[;,})\]])
      patterns:
      - include: '#type'

  typeof-operator:
    name: keyword.operator.typeof.ts
    match: (?<!\.|\$)\btypeof\b(?!\$)

  operators:
    patterns:
    - name: keyword.operator.assignment.compound.ts
      match: \*=|(?<!\()/=|%=|\+=|\-=
    - name: keyword.operator.assignment.compound.bitwise.ts
      match: \&=|\^=|<<=|>>=|>>>=|\|=
    - name: keyword.operator.comparison.ts
      match: ===|!==|==|!=
    - name: keyword.operator.relational.ts
      match: <=|>=|<>|<|>
    - name: keyword.operator.logical.ts
      match: \!|&&|\|\|
    - name: keyword.operator.bitwise.ts
      match: \&|~|\^|\|
    - name: keyword.operator.assignment.ts
      match: \=
    - name: keyword.operator.decrement.ts
      match: --
    - name: keyword.operator.increment.ts
      match: \+\+
    - name: keyword.operator.arithmetic.ts
      match: '%|\*|/|-|\+'

  arrow-function:
    patterns:
    - name: meta.arrow.ts
      match: (?<!\.|\$)(\basync)(?=\s*[<(])
      captures:
        '1': { name: storage.modifier.async.ts }
    # paramters of the arrow
    - name: meta.arrow.ts
      match: (?:(?<!\.|\$)(\basync)\s*)?([_$[:alpha:]][_$[:alnum:]]*)\s*(?==>)
      captures:
        '1': { name: storage.modifier.async.ts }
        '2': { name: variable.parameter.ts }
    - name: meta.arrow.ts
      begin: (?x)(?<=return|throw|yield|await|async|default|[=(\[,:>*])\s*(?=(<([^<>]|\<[^<>]+\>)+>\s*)?\(([^()]|\([^()]*\))*\)(\s*:\s*(.)*)?\s*=>)
      end: (?==>)
      patterns:
      - include: '#comment'
      - include: '#type-parameters'
      - include: '#function-parameters'
      # return type of the arrow
      - include: '#arrow-return-type'
    # arrow operator
    - name: meta.arrow.ts
      begin: =>
      beginCaptures:
        '0': { name: storage.type.function.arrow.ts }
      end: (?<=\})|((?!\{)(?=\S))
      patterns:
      - include: '#decl-block'
      - include: '#expression'

  arrow-return-type:
    name: meta.return.type.arrow.ts
    begin: '(?<=\))\s*(:)'
    beginCaptures:
      '1': { name: keyword.operator.type.annotation.ts }    
    end: (?<!:)((?=$)|(?==>|;|//))
    patterns:
    # TODO: handle the fn and constructor type specifically.
    - include: '#type-predicate-operator'
    - include: '#type'

  punctuation-comma:
    name: punctuation.separator.comma.ts
    match: ','

  punctuation-semicolon:
    name: punctuation.terminator.statement.ts
    match: ';'

  punctuation-accessor:
    name: punctuation.accessor.ts
    match: '\.'

  paren-expression:
    begin: \(
    beginCaptures:
      '0': {name: meta.brace.round.ts }
    end: \)
    endCaptures:
      '0': {name: meta.brace.round.ts }
    patterns:
    - include: '#expression'
    - include: '#punctuation-comma'

  qstring-double:
    name: string.quoted.double.ts
    begin: '"'
    beginCaptures:
      '0': { name: punctuation.definition.string.begin.ts }
    end: '(")|((?:[^\\\n])$)'
    endCaptures:
      '1': { name: punctuation.definition.string.end.ts }
      '2': { name: invalid.illegal.newline.ts }
    patterns:
    - include: '#string-character-escape'

  qstring-single:
    name: string.quoted.single.ts
    begin: "'"
    beginCaptures:
      '0': { name: punctuation.definition.string.begin.ts }
    end: (\')|((?:[^\\\n])$)
    endCaptures:
      '1': { name: punctuation.definition.string.end.ts }
      '2': { name: invalid.illegal.newline.ts }
    patterns:
    - include: '#string-character-escape'

  regex:
    name: string.regex.ts
    begin: (?<=[=(:,\[?+!]|return|case|=>|&&|\|\||\*\/)\s*(/)(?![/*+?])(?=.*/)
    beginCaptures:
      '1': {name: punctuation.definition.string.begin.ts}
    end: (/)([gimuy]*)
    endCaptures:
      '1': {name: punctuation.definition.string.end.ts}
      '2': {name: keyword.other.ts}
    patterns:
    - include: '#regexp'

  # regexp syntax is taken from https://github.com/atom/language-javascript/
  regexp:
    patterns:
    - name: keyword.control.anchor.regexp
      match: \\[bB]|\^|\$
    - name: keyword.other.back-reference.regexp
      match: \\[1-9]\d*
    - name: keyword.operator.quantifier.regexp
      match: '[?+*]|\{(\d+,\d+|\d+,|,\d+|\d+)\}\??'
    - name: keyword.operator.or.regexp
      match: \|
    - name: meta.group.assertion.regexp
      begin: (\()((\?=)|(\?!))
      beginCaptures:
        '1': {name: punctuation.definition.group.regexp}
        '2': {name: punctuation.definition.group.assertion.regexp}
        '3': {name: meta.assertion.look-ahead.regexp}
        '4': {name: meta.assertion.negative-look-ahead.regexp}
      end: (\))
      endCaptures:
        '1': {name: punctuation.definition.group.regexp}
      patterns:
      - include: '#regexp'
    - name: meta.group.regexp
      begin: \((\?:)?
      beginCaptures:
        '0': {name: punctuation.definition.group.regexp}
        '1': {name: punctuation.definition.group.capture.regexp}
      end: \)
      endCaptures:
        '0': {name: punctuation.definition.group.regexp}
      patterns:
      - include: '#regexp'
    - name: constant.other.character-class.set.regexp
      begin: (\[)(\^)?
      beginCaptures:
        '1': {name: punctuation.definition.character-class.regexp}
        '2': {name: keyword.operator.negation.regexp}
      end: (\])
      endCaptures:
        '1': {name: punctuation.definition.character-class.regexp}
      patterns:
      - name: constant.other.character-class.range.regexp
        match: (?:.|(\\(?:[0-7]{3}|x\h\h|u\h\h\h\h))|(\\c[A-Z])|(\\.))\-(?:[^\]\\]|(\\(?:[0-7]{3}|x\h\h|u\h\h\h\h))|(\\c[A-Z])|(\\.))
        captures:
          '1': {name: constant.character.numeric.regexp}
          '2': {name: constant.character.control.regexp}
          '3': {name: constant.character.escape.backslash.regexp}
          '4': {name: constant.character.numeric.regexp}
          '5': {name: constant.character.control.regexp}
          '6': {name: constant.character.escape.backslash.regexp}
      - include: '#regex-character-class'
    - include: '#regex-character-class'

  regex-character-class:
    patterns:
    - name: constant.other.character-class.regexp
      match: \\[wWsSdDtrnvf]|\.
    - name: constant.character.numeric.regexp
      match: \\([0-7]{3}|x\h\h|u\h\h\h\h)
    - name: constant.character.control.regexp
      match: \\c[A-Z]
    - name: constant.character.escape.backslash.regexp
      match: \\.

  string:
    name: string.ts
    patterns:
    - include: '#qstring-single'
    - include: '#qstring-double'

  template:
    name: string.template.ts
    begin: '([_$[:alpha:]][_$[:alnum:]]*)?(`)'
    beginCaptures:
      '1': { name: entity.name.function.tagged-template.ts }
      '2': { name: punctuation.definition.string.template.begin.ts }
    end: '`'
    endCaptures:
      '0': { name: punctuation.definition.string.template.end.ts}
    patterns:
     - include: '#template-substitution-element'
     - include: '#string-character-escape'

  string-character-escape:
    name: constant.character.escape.ts
    match: \\(x\h{2}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.|$)

  template-substitution-element:
    name: meta.template.expression.ts
    begin: \$\{
    beginCaptures:
      '0': { name: punctuation.definition.template-expression.begin.ts }
    end: \}
    endCaptures:
      '0': { name: punctuation.definition.template-expression.end.ts }
    patterns:
      - include: '#expression'

  literal:
    name: literal.ts
    patterns:
    - include: '#numeric-literal'
    - include: '#boolean-literal'
    - include: '#null-literal'
    - include: '#undefined-literal'
    - include: '#numericConstant-literal'
    - include: '#array-literal'
    - include: '#this-literal'
    - include: '#super-literal'

  array-literal:
    name: meta.array.literal.ts
    begin: \[
    beginCaptures:
      '0': { name: meta.brace.square.ts }
    end: \]
    endCaptures:
      '0': { name: meta.brace.square.ts }
    patterns:
    - include: '#expression'
    - include: '#punctuation-comma'

  numeric-literal:
    patterns:
    - name: constant.numeric.hex.ts
      match: \b(?<!\$)0(x|X)[0-9a-fA-F]+\b(?!\$)
    - name: constant.numeric.binary.ts
      match: \b(?<!\$)0(b|B)[01]+\b(?!\$)
    - name: constant.numeric.octal.ts
      match: \b(?<!\$)0(o|O)?[0-7]+\b(?!\$)
    - match: |-
        (?x)
        (?<!\$)(?:
          (?:\b[0-9]+(\.)[0-9]+[eE][+-]?[0-9]+\b)| # 1.1E+3
          (?:\b[0-9]+(\.)[eE][+-]?[0-9]+\b)|       # 1.E+3
          (?:\B(\.)[0-9]+[eE][+-]?[0-9]+\b)|       # .1E+3
          (?:\b[0-9]+[eE][+-]?[0-9]+\b)|            # 1E+3
          (?:\b[0-9]+(\.)[0-9]+\b)|                # 1.1
          (?:\b[0-9]+(\.)\B)|                      # 1.
          (?:\B(\.)[0-9]+\b)|                      # .1
          (?:\b[0-9]+\b(?!\.))                     # 1
        )(?!\$)
      captures:
        '0': {name: constant.numeric.decimal.ts}
        '1': {name: meta.delimiter.decimal.period.ts}
        '2': {name: meta.delimiter.decimal.period.ts}
        '3': {name: meta.delimiter.decimal.period.ts}
        '4': {name: meta.delimiter.decimal.period.ts}
        '5': {name: meta.delimiter.decimal.period.ts}
        '6': {name: meta.delimiter.decimal.period.ts}

  boolean-literal:
    patterns:
    - name: constant.language.boolean.true.ts
      match: (?<!\.|\$)\btrue\b(?!\$)
    - name: constant.language.boolean.false.ts
      match: (?<!\.|\$)\bfalse\b(?!\$)

  null-literal:
    name: constant.language.null.ts
    match: (?<!\.|\$)\bnull\b(?!\$)

  this-literal:
    name: variable.language.this.ts
    match: (?<!\.|\$)\bthis\b(?!\$)

  super-literal:
    name: variable.language.super.ts
    match: (?<!\.|\$)\bsuper\b(?!\$)

  undefined-literal:
    name: constant.language.undefined.ts
    match: (?<!\.|\$)\bundefined\b(?!\$)

  numericConstant-literal:
    patterns:
    - name: constant.language.nan.ts
      match: (?<!\.|\$)\bNaN\b(?!\$)
    - name: constant.language.infinity.ts
      match: (?<!\.|\$)\bInfinity\b(?!\$)

  access-modifier:
    name: storage.modifier.ts
    match: (?<!\.|\$)\b(public|protected|private|readonly)\b(?!\$)

  static-modifier:
    name: storage.modifier.ts
    match: (?<!\.|\$)\b(static)\b(?!\$)

  property-accessor:
    name: storage.type.property.ts
    match: (?<!\.|\$)\b(get|set)\b(?!\$)

  comment:
    patterns:
    - name: comment.block.documentation.ts
      begin: /\*\*(?!/)
      end: \*/
      captures:
        '0': {name: punctuation.definition.comment.ts}
      patterns:
      - include: '#docblock'
    - name: comment.block.ts
      begin: /\*
      end: \*/
      captures:
        '0': {name: punctuation.definition.comment.ts}
    - begin: (^[ \t]+)?(?=//)
      beginCaptures:
        '1': {name: punctuation.whitespace.comment.leading.ts}
      end: (?=$)
      patterns:
      - name: comment.line.double-slash.ts
        begin: //
        beginCaptures:
          '0': {name: punctuation.definition.comment.ts}
        end: (?=$)

  docblock:
    patterns:
    - name: storage.type.class.jsdoc
      match: (?<!\w)@(abstract|access|alias|arg|argument|async|attribute|augments|author|beta|borrows|bubbes|callback|chainable|class|classdesc|code|config|const|constant|constructor|constructs|copyright|default|defaultvalue|define|deprecated|desc|description|dict|emits|enum|event|example|exports?|extends|extension|extension_for|extensionfor|external|file|fileoverview|final|fires|for|function|global|host|ignore|implements|inherit[Dd]oc|inner|instance|interface|kind|lends|license|listens|main|member|memberof|method|mixex|mixins?|module|name|namespace|nocollapse|nosideeffects|override|overview|package|param|preserve|private|prop|property|protected|public|read[Oo]nly|record|require[ds]|returns?|see|since|static|struct|submodule|summary|template|this|throws|todo|tutorial|type|typedef|unrestricted|uses|var|variation|version|virtual|writeOnce)\b
    - match: |-
          (?x)
          (?:(?<=@param)|(?<=@type))
          \s+
          ({(?:
            \* |                                        # {*} any type
            \? |                                        # {?} unknown type

            (?:                                          # Check for a prefix
              \? |                                      # {?string} nullable type
              !   |                                      # {!string} non-nullable type
              \.{3}                                     # {...string} variable number of parameters
            )?

            (?:
              \(                                        # Opening bracket of multiple types with parenthesis {(string|number)}
                [a-zA-Z_$]+
                (?:
                  (?:
                    [\w$]*
                    (?:\[\])?                          # {(string[]|number)} type application, an array of strings or a number
                  ) |
                  <[\w$]+(?:,\s+[\w$]+)*>             # {Array<string>} or {Object<string, number>} type application
                )
                (?:
                  [\.|~]                                # {Foo.bar} namespaced, {string|number} multiple, {Foo~bar} class-specific callback
                  [a-zA-Z_$]+
                  (?:
                    (?:
                      [\w$]*
                      (?:\[\])?                        # {(string|number[])} type application, a string or an array of numbers
                    ) |
                    <[\w$]+(?:,\s+[\w$]+)*>           # {Array<string>} or {Object<string, number>} type application
                  )
                )*
              \) |
              [a-zA-Z_$]+
              (?:
                (?:
                  [\w$]*
                  (?:\[\])?                            # {string[]|number} type application, an array of strings or a number
                ) |
                <[\w$]+(?:,\s+[\w$]+)*>               # {Array<string>} or {Object<string, number>} type application
              )
              (?:
                [\.|~]                                  # {Foo.bar} namespaced, {string|number} multiple, {Foo~bar} class-specific callback
                [a-zA-Z_$]+
                (?:
                  [\w$]* |
                  <[\w$]+(?:,\s+[\w$]+)*>             # {Array<string>} or {Object<string, number>} type application
                )
              )*
            )
                                                         # Check for suffix
            (?:\[\])?                                  # {string[]} type application, an array of strings
            =?                                           # {string=} optional parameter
          )})
          \s+
          (
            \[                                          # [foo] optional parameter
              \s*
              (?:
                [a-zA-Z_$][\w$]*
                (?:
                  (?:\[\])?                            # Foo[].bar properties within an array
                  \.                                    # Foo.Bar namespaced parameter
                  [a-zA-Z_$][\w$]*
                )*
                (?:
                  \s*
                  =                                      # [foo=bar] Default parameter value
                  \s*
                  [\w$\s]*
                )?
              )
              \s*
            \] |
            (?:
              [a-zA-Z_$][\w$]*
              (?:
                (?:\[\])?                              # Foo[].bar properties within an array
                \.                                      # Foo.Bar namespaced parameter
                [a-zA-Z_$][\w$]*
              )*
            )?
          )
          \s+
          ((?:(?!\*\/).)*)                             # The type description
      captures:
        '0': { name: other.meta.jsdoc }
        '1': { name: entity.name.type.instance.jsdoc }
        '2': { name: variable.other.jsdoc }
        '3': { name: other.description.jsdoc }
    - match: |-
          (?x)
          ({(?:
            \* |                                        # {*} any type
            \? |                                        # {?} unknown type

            (?:                                          # Check for a prefix
              \? |                                      # {?string} nullable type
              !   |                                      # {!string} non-nullable type
              \.{3}                                     # {...string} variable number of parameters
            )?

            (?:
              \(                                        # Opening bracket of multiple types with parenthesis {(string|number)}
                [a-zA-Z_$]+
                (?:
                  [\w$]* |
                  <[\w$]+(?:,\s+[\w$]+)*>             # {Array<string>} or {Object<string, number>} type application
                )
                (?:
                  [\.|~]                                # {Foo.bar} namespaced, {string|number} multiple, {Foo~bar} class-specific callback
                  [a-zA-Z_$]+
                  (?:
                    [\w$]* |
                    <[\w$]+(?:,\s+[\w$]+)*>           # {Array<string>} or {Object<string, number>} type application
                  )
                )*
              \) |
              [a-zA-Z_$]+
              (?:
                [\w$]* |
                <[\w$]+(?:,\s+[\w$]+)*>               # {Array<string>} or {Object<string, number>} type application
              )
              (?:
                [\.|~]                                  # {Foo.bar} namespaced, {string|number} multiple, {Foo~bar} class-specific callback
                [a-zA-Z_$]+
                (?:
                  [\w$]* |
                  <[\w$]+(?:,\s+[\w$]+)*>             # {Array<string>} or {Object<string, number>} type application
                )
              )*
            )
                                                         # Check for suffix
            (?:\[\])?                                  # {string[]} type application, an array of strings
            =?                                           # {string=} optional parameter
          )})
          \s+
          ((?:(?!\*\/).)*)                             # The type description
      captures:
        '0': { name: other.meta.jsdoc }
        '1': { name: entity.name.type.instance.jsdoc }
        '2': { name: other.description.jsdoc }

...
